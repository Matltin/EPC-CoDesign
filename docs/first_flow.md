باشه—بیایم پروژه رو دقیق و «قابل پیاده‌سازی با پایتون» طراحی کنیم، طوری که هم با متن پروژه همخوان باشه و بعداً راحت بشه بخش‌های گلوگاهی رو برای همطراحی (HW/SW) جدا کرد. (چهار فاز پروژه هم همین‌هاست: درک مفهومی، پیاده‌سازی، تحلیل پیچیدگی/گلوگاه، مدل‌سازی SystemC) 

---

## 1) خروجی نهایی که باید داشته باشی

طبق فایل پروژه، خروجی‌ها عملاً این‌هاست: 

1. **کد EPC** (Python یا …) با قابلیت تغییر پارامترها
2. **اجرای الگوریتم روی بنچمارک‌ها** (حداقل Sphere و Rosenbrock) و ارائه نمودار/نتایج 
3. **تحلیل پیچیدگی و گلوگاه‌ها** (کجای الگوریتم زمان می‌برد) 
4. (اختیاری/مرحله بعد) **تفکیک SW/HW و مدل SystemC** 

---

## 2) طراحی نرم‌افزار: ساختار پیشنهادی پروژه پایتون

پیشنهاد می‌کنم از همین اول تمیز بچینیم:

* `objectives.py`

  * `sphere(x)`
  * `rosenbrock(x)`
  * (قابلیت اضافه کردن تابع جدید)
* `epc.py`

  * کلاس/تابع اصلی EPC
  * مدیریت پارامترها، حلقه تکرار، آپدیت جمعیت
* `experiments.py`

  * اجرای چندباره با seedهای مختلف
  * گرفتن آمار و نمودار همگرایی
* `utils.py`

  * clip کردن به بازه، لاگ، ذخیره نتایج

این ساختار بعداً برای همطراحی هم عالیه چون دقیقاً می‌بینی «کدام تابع/بخش» باید HW شود.

---

## 3) تعریف مسئله به زبان کد

هر پنگوئن = یک جواب کاندید:

* جمعیت: `X` با شکل `(N, D)`
* کران‌ها: `LB`, `UB` (بردار طول D یا اسکالر)
* تابع هدف: `f(x)` (برای مینیمم کردن—ولی می‌تونی گزینه ماکزیمم هم اضافه کنی) 

شرط توقف هم طبق فایل:

* یا `t == Tmax`
* یا `f(best) <= ε` 

---

## 4) پارامترهای EPC که باید توی کد داشته باشی

از متن پروژه این‌ها کلیدی‌اند: 

* `N`: تعداد پنگوئن‌ها
* `D`: تعداد ابعاد
* `Tmax`: تعداد تکرار
* `epsilon`: آستانه خطا (اختیاری)
* پارامترهای مارپیچ: `a=1`, `b=0.5` 
* تضعیف گرما (جذابیت):

  * `mu0 = 0.05`
  * `mu <- 0.99 * mu` در هر تکرار 
* نویز/انحراف تصادفی:

  * `m0 = 0.5`
  * `m <- 0.99 * m` در هر تکرار
  * `u ~ U(-1, 1)` و `x_new += m*u` 

---

## 5) گام‌های الگوریتم EPC (استپ‌به‌استپ دقیق برای پیاده‌سازی)

### گام 0) مقداردهی اولیه جمعیت

برای هر پنگوئن و هر بعد:

* `x[i,d] = LB[d] + r*(UB[d]-LB[d])` که `r ~ U(0,1)` 
  بعد:
* `fitness[i] = f(x[i])`
* `best_idx = argmin(fitness)` و `x_best = x[best_idx]` 

---

### گام 1) حلقه تکرار اصلی (برای t از 1 تا Tmax)

در ابتدای هر تکرار:

* `mu *= 0.99`
* `m  *= 0.99` 

---

### گام 2) برای هر پنگوئن i: محاسبه فاصله و جذابیت Q

طبق فایل، جذابیت/گرما این شکلی کاهش پیدا می‌کند: 

1. فاصله تا بهترین:

* `D_i = || x_best - x_i ||2`  (فاصله اقلیدسی) 

2. جذابیت:

* `Q = exp(-mu * D_i)`
  (خود exp خروجی (0,1] می‌دهد، معمولاً همین کافی است.) 

---

### گام 3) آپدیت مارپیچی مختصات

اینجا نکته‌ی مهم فایل پروژه این است که **آپدیت مارپیچ روی یک جفت بعد انجام می‌شود** (در متن هم با `p` و `q` آمده) و در مثال هم برای همه جفت‌بعدها (1,2)، (1,3)، … این کار را تکرار می‌کند. 

پس دو روش استاندارد برای پیاده‌سازی داری (من هر دو را می‌نویسم تا انتخاب کنی):

#### روش A) دقیق‌تر (ولی سنگین‌تر): همه جفت‌بعدها

برای هر جفت `(p,q)` که `p<q`:

1. زاویه‌ها:

* `theta_i = atan2(x_i[q], x_i[p])`
* `theta_b = atan2(x_best[q], x_best[p])`
  (برای جلوگیری از تقسیم بر صفر، `atan2` بهتر از `tan^-1(x/y)` است.)

2. ترکیب زاویه (طبق رابطه فایل):

* `theta_k = (1/b) * ln( (1 - Q)*exp(b*theta_b) + Q*exp(b*theta_i) )` 

3. شعاع:

* `r_k = a * exp(b * theta_k)` 

4. مقدار جدید در آن دو بعد:

* `x_i[p] = r_k * cos(theta_k)`
* `x_i[q] = r_k * sin(theta_k)` 

#### روش B) سریع‌تر: فقط چند جفت‌بعد تصادفی در هر تکرار

به‌جای همه جفت‌ها، مثلاً 1 تا 3 جفت تصادفی انتخاب کن و همان آپدیت بالا را اعمال کن.
این روش برای **بعدهای بزرگ** خیلی کاربردی است چون روش A پیچیدگی را شدیداً بالا می‌برد (این دقیقاً همان چیزی است که در بخش گلوگاه‌ها به درد می‌خورد).

---

### گام 4) افزودن انحراف تصادفی به کل بردار

طبق فایل: 

* `u ~ U(-1,1)` (برای هر بعد یک مقدار)
* `x_i += m * u`

*(نکته عملی: اگر دیدی گام نویز برای بعضی مسئله‌ها زیاد/کم است، می‌شود `m*u*(UB-LB)` هم کرد تا مقیاس با بازه هماهنگ شود—ولی نسخه‌ی پایه همان متن فایل است.)*

---

### گام 5) کنترل کران‌ها (Bounds)

طبق فایل اگر بیرون بازه افتاد:

* clip: `x_i[d] = min(max(x_i[d], LB[d]), UB[d])` 

---

### گام 6) ارزیابی دوباره و آپدیت بهترین

* `fitness[i] = f(x_i)`
* اگر بهتر از بهترین بود: `x_best = x_i`

و در پایان هر تکرار، شرط توقف را چک کن. 

---

## 6) بنچمارک‌هایی که باید اجرا کنی

طبق پروژه حداقل این دو تا: 

* **Sphere**:  (\sum x_i^2)
* **Rosenbrock**:  (\sum_{i=1}^{D-1} [100(x_{i+1}-x_i^2)^2 + (x_i-1)^2]) 

### خروجی‌های آزمایش که بهتره بگیری

* نمودار `best_fitness` برحسب iteration
* نتیجه نهایی بهترین جواب و مقدار تابع
* (اگر چند اجرا می‌زنی) میانگین/انحراف معیار بهترین مقدار

---

## 7) تحلیل پیچیدگی و گلوگاه‌ها (برای بخش همطراحی)

این دقیقاً همان چیزی است که پروژه می‌خواهد شناسایی کنی. 

### اگر روش A (همه جفت‌بعدها) را پیاده کنی:

* تعداد جفت‌بعدها:  (\frac{D(D-1)}{2})
* برای هر پنگوئن در هر تکرار: O(D²) عملیات (عمدتاً log/exp/sin/cos/atan2)
* کل: **O(T * N * D²)**  ← این می‌شود گلوگاه اصلی

### اگر روش B (چند جفت‌بعد) را پیاده کنی:

* کل: **O(T * N * D)** تقریباً (خیلی مناسب‌تر)

### گلوگاه‌های واضح برای HW کردن

* ارزیابی تابع هدف برای کل جمعیت (خصوصاً اگر تابع سنگین باشد)
* محاسبه فاصله‌ها و Q
* حلقه آپدیت مارپیچی (trig/exp/log)
  این‌ها دقیقاً بهترین کاندیدهای شتاب‌دهنده‌اند.

---

## 8) نقشه تفکیک SW/HW برای مدل SystemC (برای وقتی رفتی فاز 4)

طبق فازهای پروژه، ایده‌ی تمیز این است: 

### بخش نرم‌افزار (SW / کنترل)

* مدیریت iteration و شرط توقف
* آپدیت پارامترهای `mu` و `m`
* انتخاب بهترین پنگوئن (`argmin`)
* مدیریت seed و لاگ و گزارش

### بخش سخت‌افزار (HW / کرنل محاسباتی)

* ورودی: `X` (جمعیت) + `x_best` + `mu, m`
* خروجی: `X_new` + `fitness_new`
* داخل HW: distance + Q + spiral update + noise + clip

**SystemC مدل حداقلی**

* `sw_controller` (thread)
* `hw_epc_kernel` (module با latency مدل‌شده)
* یک رابط ساده FIFO/Handshake برای ارسال/دریافت بردارها

---

## 9) قدم بعدی

اگه با این طراحی اوکی هستی، توی پیام بعدی می‌ریم سراغ **کدنویسی EPC در پایتون** به‌شکل تمیز و قابل تست (با Sphere و Rosenbrock، ذخیره تاریخچه best، و امکان انتخاب روش A/B برای آپدیت ابعاد).
