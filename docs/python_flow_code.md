باشه؛ بیایم دقیقاً **فقط مسیر Sphere** را از داخل `__main__` قدم‌به‌قدم دنبال کنیم تا مثل «ردیابی اجرا» بفهمی چه اتفاقی می‌افتد.

---

## 0) نقطه شروع: `if __name__ == "__main__":`

وقتی `python experiments.py` را اجرا می‌کنی، این بلاک شروع می‌شود.

### 0.1) ساخت کانفیگ

```python
cfg = EPCConfig(
    N=25,
    Tmax=150,
    epsilon=1e-10,
    verbose=True
)
```

یعنی:

* **N=25** → ۲۵ پنگوئن (۲۵ جواب همزمان)
* **Tmax=150** → حداکثر ۱۵۰ iteration
* **epsilon=1e-10** → اگر `best_f <= 1e-10` شد، توقف زودهنگام
* **verbose=True** → هر چند iteration وضعیت چاپ می‌شود

---

## 1) اجرای Sphere از مین

این خط اجرا می‌شود:

```python
res_sphere = run_single_experiment(
    name="Sphere",
    obj_func=sphere,
    D=10,
    lb=-5.0,
    ub=5.0,
    cfg=cfg,
    seed=42
)
```

پس برای Sphere داریم:

* **تابع هدف:** `sphere(x) = sum(x^2)`
* **بعد مسئله:** `D=10` (هر جواب یک بردار ۱۰ بعدی است)
* **bounds:** هر بعد داخل `[-5, +5]`
* **seed=42:** برای تکرارپذیری کل روند تصادفی

---

## 2) داخل `run_single_experiment` چه می‌شود؟

### 2.1) صدا زدن الگوریتم

```python
res = epc_optimize(obj_func=obj_func, D=D, lb=lb, ub=ub, config=cfg, seed=seed)
```

از اینجا وارد `epc_optimize` می‌شویم.

---

## 3) داخل `epc_optimize` برای Sphere (قدم‌به‌قدم)

### 3.1) RNG و bounds

* RNG ساخته می‌شود: `rng = np.random.default_rng(42)`
* bounds استاندارد می‌شوند:

  * چون `lb=-5.0` اسکالر است → تبدیل به `LB شکل (10,)` همه‌اش -5
  * چون `ub=5.0` اسکالر است → تبدیل به `UB شکل (10,)` همه‌اش +5

پس:

* `LB.shape == (10,)`
* `UB.shape == (10,)`

---

### 3.2) ساخت جمعیت اولیه (۲۵ جواب ۱۰ بعدی)

```python
X = initialize_population(rng, N=25, D=10, LB, UB)
```

خروجی:

* `X.shape == (25, 10)`
* هر عنصر `X[i, j]` یک عدد تصادفی یکنواخت بین -5 و +5 است.

مثلاً ذهنی:

* پنگوئن 0: `[ 1.2, -3.4, ... ]`
* پنگوئن 1: `[-0.7,  4.9, ... ]`
* ...

---

### 3.3) محاسبه fitness اولیه روی Sphere

```python
fitness = evaluate_population(obj_func, X)
```

اینجا برای هر پنگوئن:

* `sphere(x) = sum(x^2)`

پس:

* `fitness.shape == (25,)`
* مقدارها **همیشه غیرمنفی** هستند
* هر چه بردار به صفر نزدیک‌تر باشد، fitness کوچک‌تر است.

---

### 3.4) پیدا کردن بهترین اولیه

```python
best_idx = argmin(fitness)
g_best_x = X[best_idx]
g_best_f = fitness[best_idx]
```

یعنی:

* `g_best_x.shape == (10,)`
* `g_best_f` یک عدد float

و تاریخچه:

```python
history[0] = g_best_f
```

اگر `verbose=True`:

* `[init] best_f=...` چاپ می‌شود.

---

## 4) حالا حلقه اصلی EPC شروع می‌شود (برای Sphere)

کد:

```python
mu = mu0
m  = m0
for it in range(1, Tmax+1):
    mu *= mu_decay
    m  *= m_decay
    for i in range(N):
        X[i] = update_penguin_method_A(..., x_i=X[i], x_best=g_best_x, mu=mu, m=m, ...)
    fitness = evaluate_population(sphere, X)
    ...
    history[it] = g_best_f
    if g_best_f <= epsilon: break
```

### مهم‌ترین نکته برای Sphere

چون Sphere کمینه‌اش در **x=0** است:

* بهینه یعنی حرکت به سمت صفر شدن مؤلفه‌ها

اما EPC تو “مستقیم” گرادیان نمی‌گیرد؛ از ترکیب:

* **جذب نسبت به بهترین فعلی** (`x_best`)
* **مارپیچ روی جفت‌بعدها**
* **نویز کنترل‌شونده**

استفاده می‌کند.

---

## 5) یک iteration را کاملاً ریز کنیم (برای Sphere)

فرض کن در iteration `it` هستیم.

### 5.1) کاهش پارامترها

* `mu` کمی کوچک‌تر می‌شود
* `m` کمی کوچک‌تر می‌شود (نویز کمتر → حرکت‌ها آرام‌تر)

---

### 5.2) آپدیت هر پنگوئن با روش A

برای هر `i`:

#### (الف) فاصله تا بهترین

```python
dist = ||x_best - x_i||
```

* اگر پنگوئن خیلی دور باشد → dist بزرگ
* اگر نزدیک باشد → dist کوچک

#### (ب) محاسبه Q

```python
Q = exp(-mu * dist)
```

* dist بزرگ → Q کوچک‌تر
* dist کوچک → Q نزدیک‌تر به 1

#### (ج) مارپیچ روی همه جفت‌بعدها (p<q)

برای هر جفت بعد مثل (0,1)، (0,2)، ...، (8,9):

* زاویه‌ی پنگوئن روی صفحه‌ی (p,q):
  [
  \theta_i = atan2(x[q], x[p])
  ]
* زاویه‌ی بهترین روی همان صفحه:
  [
  \theta_b = atan2(best[q], best[p])
  ]

بعد یک زاویه جدید می‌سازد (طبق فرمول کد) و سپس:

* مختصات p و q را دوباره می‌نویسد:
  [
  x[p]=r\cos(\theta),\quad x[q]=r\sin(\theta)
  ]

✅ نتیجه عملی:
در هر iteration، هر پنگوئن روی همه صفحات دوبعدی «می‌پیچد» و شکل حرکتش ترکیبی از بهترین فعلی و خودش است.

> نکته‌ی مهم: چون روی همه جفت‌ها می‌چرخی، هر بعد چند بار overwrite می‌شود و مسیر حرکت “پیچ‌پیچی/آشوبناک‌تر” از آپدیت تک‌بعدی است.

#### (د) افزودن نویز

```python
x_new = x_new + m * U(-1,1)
```

یعنی یک تکان تصادفی کوچک برای escape و جستجو.

#### (هـ) clip به [-5,5]

اگر چیزی از بازه زد بیرون، برمی‌گردد داخل.

---

### 5.3) محاسبه fitness جدید (Sphere)

بعد از اینکه همه ۲۵ پنگوئن آپدیت شدند:

```python
fitness = sphere(X[i]) برای همه i
```

### 5.4) آپدیت بهترین جهانی

اگر یکی از پنگوئن‌ها بهتر از بهترین قبلی شد:

* `g_best_f` کوچکتر می‌شود
* `g_best_x` آپدیت می‌شود

### 5.5) ثبت تاریخچه

```python
history[it] = g_best_f
```

این همان چیزی است که بعداً نمودار همگرایی می‌کشد.

### 5.6) شرط توقف Sphere

اگر `g_best_f <= 1e-10`:

* حلقه قطع می‌شود
* history هم کوتاه می‌شود

---

## 6) خروج از `epc_optimize` و برگشت به مین

`epc_optimize` یک `EPCResult` می‌دهد:

* `best_x`: بهترین بردار ۱۰بعدی پیدا شده
* `best_f`: مقدار Sphere روی آن (نزدیک صفر)
* `history_best_f`: لیست بهترین‌ها در طول iteration
* `elapsed_sec`: زمان اجرا
* `meta`: اطلاعات مثل iters_done و seed و ...

---

## 7) بعدش در مین چه می‌شود؟ (فقط Sphere)

بعد از اینکه `res_sphere` برگشت:

### 7.1) رسم نمودار همگرایی

```python
plot_convergence("EPC Convergence - Sphere", res_sphere.history_best_f)
```

پس نمودار:

* از iteration 0 شروع می‌شود (best اولیه)
* معمولاً نزولی است (به سمت صفر)

---

## 8) اگر بخوای “ذهنی” حسش کنی (Sphere)

* در ابتدا هر پنگوئن یک بردار تصادفی توی [-5,5] است → `sphere` معمولاً عدد نسبتاً بزرگ
* بهترین اولیه، آن کسی است که تصادفاً نزدیک‌تر به صفر افتاده
* iteration به iteration:

  * همه سعی می‌کنند با مارپیچ و جذب، حول بهترین حرکت کنند
  * نویز کمک می‌کند گیر نکنند
  * بهترین کم‌کم به سمت `x≈0` می‌رود
  * `best_f` نزدیک ۰ می‌شود

---

## یک پیشنهاد خیلی کاربردی برای اینکه کاملاً “مرحله‌ای ببینی”

اگر دوست داری دقیقاً بفهمی داخل هر iteration چه می‌شود، ساده‌ترین کار این است که داخل حلقه‌ی EPC این چیزها را چاپ کنی:

* `g_best_f`
* `mean(fitness)` (میانگین کیفیت جمعیت)
* `||g_best_x||` (نُرم بهترین جواب → برای Sphere باید به ۰ نزدیک شود)

اگر بخوای، همین الآن دقیقاً می‌گم **کجا و چه پرینت‌هایی** بگذاری که اجرای Sphere را مثل “لاگ آموزشی” ببینی (بدون اینکه خروجی خیلی شلوغ شود).
